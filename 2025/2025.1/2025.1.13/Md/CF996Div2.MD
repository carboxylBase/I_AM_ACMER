# CF996-Div2

今天来补一下昨天晚上的Cf996,E题感觉还是能做的,思维题,应该不涉及复杂的数据结构.F有点吓人了,先放放.

## E
题目意思不复杂,首先最关键的问题是怎么选择第一个要搬空的干草堆?或者我们考虑每一份干草要被搬运多少次?如果把这份干草放在未搬过的草堆上,它的贡献就要加一了.

我认为最好优先选择b值大于a的,这样这个干草堆上的干草就只需要搬运两次.但是一个显然的问题是如果没有符合条件的怎么办?还是选b-a最大的?搞不明白,看看题解.

看了提示一,实际上我们搬运肯定是按照指定顺序来的啊,这很显然,不可能搬一下这个搬一下那个的,就是显然不可能,所以这个顺序要怎么确定呢?或者说,我们退而求其次,考虑指定顺序怎么模拟结果?怎么感觉跟D有点像啊,同根同源?

提示二是让我给出对于指定顺序的操作次数表达式hhh,我就是这个不会啊hhh.难道说,还是要利用贷款的思想吗?!我有一个猜想,实际上,我们可以记录当前剩余的可用空位,以及当前被挪到未清0草堆上的草的总数,按顺序遍历所有草堆,若剩余可用空位溢出了,或者不溢出,我们分别处理,这实际上是一个贪心,不知道对不对啊.我认为这个贪心是完全正确的,而且我们可以根据最后一次更新的情况确定可不可解.

那么,要怎么计算对于指定序列的操作数呢?可以O(1)计算吗?经过一番公式推导,得到了一些有用的结论,但是我没看出来这要怎么求和,也许是我的公式推导就有问题,我打算再看一看提示三.已经很卖力的进行代数变形了...

算了提示三和四好像都是建立在二的表达式能弄出来的基础上的.直接看题解吧.开幕雷击,整体的思想很简单的就给出了合法序列的条件.题解写得好,我才看几行就感觉大有突破了,很巧妙的构造啊.实际上,我刚才模拟的过程可以进一步简化,我上面那么复杂的贪心,归结起来就是一句话:每一个干草块我最多只想移动两次.那么,我们直接把所有溢出的干草块放到最后不就行了吗?太妙了这个构造,这就是大家都喜欢贪心的原因吧!

善用max取代if语句,就可以构造出极简洁的数学公式.写不出来,再看一眼题解.是整体思想,是整体!他再一次利用了整体思想!实在是太巧妙了,只需考虑执行到第i个干草堆时溢出的总数是多少,就知道此时n位置应该存有多少额外的干草,对了,记得是取最大值.

下面的问题就在于怎么决定最优排列,其实也许我们一开始就不必想的如此复杂.实际上我们可以根据a和b的大小关系把他们分为三类,我们肯定优先处理a \< b的,因为如果把a > b 的放在前面,只会使得a < b的部分产生更大的贡献,反过来,我们可以用后者减小前者的贡献,至于a = b的部分,其实放在前两者之间最优,可以在吃到前者贡献的同时不对后者产生影响.

更细节的,对与a < b的情况,我们要把a按照升序排列,如何证明呢?交换任意一对,显然不优,所以如此正确.a = b的部分随便.a > b的部分按照b降序,同样可以用交换来证明.于是,我们就构造出最优排列,现在还剩下最后一个问题,这个最优排列不一定合法,我们可以在排序后枚举所有可能作为最后一个的干草,然后用线段树维护最大值就可以了.排序和后序查询的复杂度恰好都是O(nlogn),据说有一种O(n)的写法,我看jiangly的代码好像就是这么写的.有时间再仔细研究吧,大佬就是大佬,轻轻松松就写出了最简单的做法.感觉黑红跟普通高手确实有本质上的差距.

先去吃个饭,回来把这题做掉.

WA#2-1147th.太幽默了,上对拍.AC了,检查发现我有一步更新答案忘记赋值了...

这个题还是很经典的思维题,发现到a和b的大小关系产生的决定性影响后,这题就不难处理,但是就是这一步挡住了无数人啊.实际上这题有2500分以上的难度吧?对照了一下排行榜,确实也就2500左右的难度,2700它也大概也算不上.其实2700也不是不能战胜吧?只要愿意静下心来思考.