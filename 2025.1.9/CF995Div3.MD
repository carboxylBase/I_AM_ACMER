# CF995-DIV3

久违的来写一下CF,因为太菜所以就Div3起手了.

# A&B
略.

# C
再次让我意识到初始化的重要性.

# D
一眼二分.

# E
很显然是把每一个a和b视为一个端点,按大小排序后依次遍历并更新答案.需要注意的是有些a和b是重的,所以要做特判,还是有点细节的.

在评论区看到有人试图用扫描线做,实际上本质而言就是我这个做法吧.

# F
其实今天是7号...有点困了,剩下这些明天来写吧.

看了十分钟发现不会,遂直接看题解.假设当前joker可能在区间 $ [l,r] $ 之间出现,对于a,分三种情况讨论:
+ $a<l$:可以发现交换后新的可能区间为 $ [l-1,r] $.
+ $a>r$:可以发现交换后新的可能区间为 $ [l,r+1] $.
+ $l<=a<=r$:这个稍复杂些.对于 $ [l,a-1] $ 的部分,类似第二点,新区间为 $[l,a]$;对于区间 $ [a+1,r] $,和第一点类似,新区间为 $[a,r]$.所以总的区间为 $ [l,r] $.然后还要在首尾新加一个 $[1,1]$ 和 $[n,n]$ 区间.

我们只需依次对区间进行更新就可以了,容易发现最多只有三个区间需要处理,所以复杂度是O(q).这题n范围这么大的原因就在这里.而且注意到每次操作给区间扩张的幅度都最大为1,所以最后需要输出的数字的量级大概也就是q^2.怎么有点危险.

# G
又到了经典看不懂题目环节.英语学太差了,有必要特别解释一下这句话:
Otherwise, you win with the score equal to the maximum cell occupied by any snake so far.
意思是说迄今为止被任何蛇占用过的地方,也就是说之前被覆盖过现在没有被覆盖的也算上.

好了,我们来分析一下这个题目.容易发现,在确定了蛇的排列顺序之后,最小占用格数就确定了,我们肯定贪心的希望它能达到一种最极限的状态--在变化过程中相邻的两个蛇会挨在一起.那么,如何计算此时的得分呢?其实我们只用考虑首尾的蛇就可以了,答案就是最右侧的蛇的最终位置减去最左侧蛇的起点位置.考虑到右侧蛇最终的位置取决与其起始位置,所以实际上还是考虑序列中间需要预留多少空白.

不过显然我们不可能遍历所有排列顺序.考虑两个蛇之间的最小距离怎么算.其实就是考虑左侧蛇的右端什么时候和右侧蛇的左端相交.实际上当蛇的长度为1的时候蛇就不能收缩了,也就是说此时收缩是一个无用的步骤,好消息是我们可以提前预处理出哪些步骤是没用的,把它去除不考虑即可.那么剩下的步骤都是有效操作,我们只考虑左蛇的前进-右蛇收缩的最大值.如果这个值是小于等于0的,我们把它们紧挨在一起就可以了,否则,空开相应格数的距离.我们希望这些空格的数目尽可能少.

突然发现这题蛇的数量至多只有20个.我怎么感觉,好像是,状压dp啊.实际上可以枚举所有集合,然后尝试在序列首部或者尾部为这个集合添加一个新的元素进去,更新新集合的得分,这样就可以得到最优结果.但是复杂度如何呢?首先集合数量就有2\^10个大概1e6的数量级,然后每个状态都要向上更新10次,如果我能O(1)的求出两个蛇之间的最小花费就可以1e7的复杂度把它做出来.确实可以O(1)啊,蛇的数量少,直接O(n^2)把结果预处理出来就可以了.那么这题就写出来了???

看题解确认了一下,确实就是状压dp(这个数据范围很难不是状压dp啊),等去图书馆再慢慢写吧.

到图书馆了,仔细一想这个更新的部分没这么简单,实际上我需要知道这个集合的尾部是哪条蛇才行,设f(i,j)表示状态i下,末尾蛇为j的最小得分,那么我们总共需要更新1e7个状态,可以接受.预处理复杂度也是O(n^2*q)啊,有点危险.

折腾一个小时终于过了,实际上状态转移方程搞错了,靠着样例调了很久才改正过来.写这种题最好在草稿纸上把他们的几何关系画出来,这样不会忽略一些细节.
